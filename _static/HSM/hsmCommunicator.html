<!DOCTYPE html>
<html>
<!--
	hsmCommunicator.html

	This file automatically generated by FSMLang

-->
<head>
<title>FSM Lang : hsmCommunicator</title>
<script>window.name="FSMLang-hsmCommunicator"</script>
<link REL=stylesheet type="text/css" href="fsmlang.css">
</head><body>
<h2>hsmCommunicator</h2>
<p>
This machine manages communications using a "stop and wait" protocol. Only one message is allowed to be outstanding.

Before any message can be exchanged, however, a session must be established with the peer. Establishing a connection
requires several exchanges to authenticate. The session will remain active as long as messages continue to be
exchanged with a minimum frequency.

The user of this machine calls run_hsmCommunicator, passing the SEND_MESSAGE event.  For the first message,
the machine will be IDLE, and thus needs to queue the message, start the establishSession machine, and transition
to the ESTABLISHING_SESSION state.  Requests to send messages received in this state will simply be queued. 

While the top level machine is in the ESTABLISHING_SESSION state, the establishSession machine does the establishment work.

When the establishSession machine receives the STEP1_RESPONSE event, it reports to the top level machine that
the session is established by returning the parent's SESSION_ESTABLISHED event.  This will move the top level
machine to its IN_SESSION state and cause it to send the message(s) which are enqueued.

</p>
<table class='machine_stats'>
	<tbody>
		<tr><th>Number of events</th><td>4</td></tr>
		<tr><th>Events not handled</th><td>0</td></tr>
		<tr><th>Events handled in one state</th><td>2</td></tr>
		<tr><th>At least one event handled the same in all states?</th><td>no</td></tr>
		<tr><th>Number of states</th><td>3</td></tr>
		<tr><th>Number of states with entry functions</th><td>0</td></tr>
		<tr><th>Number of states with exit functions</th><td>0</td></tr>
		<tr><th>States handling no events</th><td>0</td></tr>
		<tr><th>States handling exactly one event</th><td>1</td></tr>
		<tr><th>States with no way in</th><td>0</td></tr>
		<tr><th>States with no way out</th><td>0</td></tr>
	</tbody>
</table>
<div class="scrollable">
<table class="machine">
	<thead>
		<tr>
			<th class="blankCorner">&nbsp;</th>
			<th class='eventName'>SEND_MESSAGE</th>
			<th class='eventName'>SESSION_ESTABLISHED</th>
			<th class='eventName'>SESSION_TIMEOUT</th>
			<th class='eventName'>MESSAGE_RECEIVED</th>
		</tr>
	</thead>
	<tbody>
	<tr>
		<th class=stateName>IDLE</th>
		<td class=action>startSessionEstablishment<br/>shares event with:
	<ul class="return_decl">
<li>sendMessage</li>
</ul>
<br/><b>transition</b> : ESTABLISHING_SESSION<p class="transition_comment"> Start the session establishment process by activating the <i>establishSession</i> machine. </p></td>
		<td class=nullAction><br/><b>transition</b> : none</td>
		<td class=nullAction><br/><b>transition</b> : none</td>
		<td class=nullAction><br/><b>transition</b> : none</td>
	</tr>
	<tr>
		<th class=stateName>ESTABLISHING_SESSION</th>
		<td class=action>queueMessage<br/>shares event with:
	<ul class="return_decl">
<li>sendMessage</li>
</ul>
<br/><b>transition</b> : none<p class="transition_comment"> Extend the session timer and queue the message </p></td>
		<td class=action>completeSessionStart<br/>returns:
	<ul class="return_decl">
		<li>noEvent</li>
	</ul>
<br/><b>transition</b> : IN_SESSION<p class="transition_comment"> Start the session timer and notify the <i>sendMessage</i> machine that the session is established. </p></td>
		<td class=nullAction><br/><b>transition</b> : none</td>
		<td class=action>passMessageReceived<br/>shares event with:
	<ul class="return_decl">
<li>establishSession</li>
<li>sendMessage</li>
</ul>
<br/><b>transition</b> : none<p class="transition_comment"> Pass the MESSAGE_RECEIVED event along. </p></td>
	</tr>
	<tr>
		<th class=stateName>IN_SESSION</th>
		<td class=action>requestMessageTransmission<br/>shares event with:
	<ul class="return_decl">
<li>sendMessage</li>
</ul>
<br/><b>transition</b> : none<p class="transition_comment"> Extend the session timer and pass the message to be sent to the <i>sendMessage</i> machine. </p></td>
		<td class=nullAction><br/><b>transition</b> : none</td>
		<td class=noAction>noAction<br/><b>transition</b> : IDLE</td>
		<td class=action>passMessageReceived<br/>shares event with:
	<ul class="return_decl">
<li>establishSession</li>
<li>sendMessage</li>
</ul>
<br/><b>transition</b> : none<p class="transition_comment"> Pass the MESSAGE_RECEIVED event along. </p></td>
	</tr>
	</tbody>
</table>
</div>
<table class="elements">
<thead><tr>
<th colspan='2' align='left'>Events</th>
</tr>
</thead>
<tbody>
<tr>
	<td colspan='2' align='left'>
<table class='summary'>
<tr><th>Total number of events:</th><td>4</td></tr>
<tr><th>Events with no handlers:</th><td>0</td></tr>
<tr><th>Events with one handler:</th><td>2</td></tr>
<tr><th>Average event state density:</th><td>58%</td></tr>
</table>
	</td>
</tr>
<tr>
<td class="label">SEND_MESSAGE</td>
<td> This event comes from our client code, asking us to send a message.
    
<p>This event is shared with:</p><ul class="return_decl">
<li>sendMessage</li>
</ul>
<p>Handled In 3 of 3 (100 %) States:</p>
	<ul>
		<li>IDLE</li>
		<li>ESTABLISHING_SESSION</li>
		<li>IN_SESSION</li>
	</ul>
<p>Causes these actions to be taken:</p>
	<ul>
		<li>startSessionEstablishment</li>
		<li>queueMessage</li>
		<li>requestMessageTransmission</li>
	</ul>
</td>
</tr>
<tr>
<td class="label">SESSION_ESTABLISHED</td>
<td> This event comes from our <i>establishSession</i> submachine, indicating that it has successfully
        completed its work.  We then forward it to our <i>sendMessage</i> submachine to indicate that
        it may now begin to send messages.
    
<p>Handled In 1 of 3 (33 %) States:</p>
	<ul>
		<li>ESTABLISHING_SESSION</li>
	</ul>
<p>Causes these actions to be taken:</p>
	<ul>
		<li>completeSessionStart</li>
	</ul>
</td>
</tr>
<tr>
<td class="label">SESSION_TIMEOUT</td>
<td> This event comes from our external timer, indicating that we've not tickled it in a while, and
        thus should close down our session.
    
<p>Handled In 1 of 3 (33 %) States:</p>
	<ul>
		<li>IN_SESSION</li>
	</ul>
</td>
</tr>
<tr>
<td class="label">MESSAGE_RECEIVED</td>
<td> This event comes from our lower comm layers, indicating that a peer message has arrived.
        While we're in the ESTABLISHING_SESSION state, we forward this event to the <i>establishSession</i>
        submachine; while in the IN_SESSION state, we forward it to the <i>sendMessage</i> submachine.
    
<p>This event is shared with:</p><ul class="return_decl">
<li>establishSession</li>
<li>sendMessage</li>
</ul>
<p>Handled In 2 of 3 (66 %) States:</p>
	<ul>
		<li>ESTABLISHING_SESSION</li>
		<li>IN_SESSION</li>
	</ul>
<p>Causes these actions to be taken:</p>
	<ul>
		<li>passMessageReceived</li>
	</ul>
</td>
</tr>
</tbody>
</table>
<table class="elements">
<thead><tr>
<th colspan=2 align=left>States</th>
</tr>
</thead>
<tbody>
<tr><td colspan='2' align='left'>
<table class='summary'>
<tr><th>Total number of states:</th><td>3</td></tr>
<tr><th>States with no events:</th><td>0</td></tr>
<tr><th>States with one event:</th><td>1</td></tr>
<tr><th>States with no way in:</th><td>0</td></tr>
<tr><th>States with no way out:</th><td>0</td></tr>
<tr><th>Average state event density:</th><td>58%</td></tr>
</table>
	</td>
</tr>
<tr>
<td class='label'>IDLE</td>
<td>
<p> The wakeup state.  Also, this is the state to which the machine
        returns when a session times out.
    </p>
<p>Inbound Transitions:</p>
	<ul>
		<li>IN_SESSION</li>
</ul>
<p>Outbound Transitions:</p>
	<ul>
		<li>ESTABLISHING_SESSION</li>
</ul>
<p>Events Handled (1 of 4 for 25%):</p>
	<ul>
		<li>SEND_MESSAGE</li>
	</ul>
<p>Actions Taken:
</p>
	<ul>
		<li>startSessionEstablishment</li>
	</ul>
</td></tr>
<tr>
<td class='label'>ESTABLISHING_SESSION</td>
<td>
<p> The machine is establishing a session.  The actual work is being done by the <i>establishSession</i>
        submachine.  While in this state, the <i>MESSAGE_RECEIVED</i> event is forwarded to that submachine.
    </p>
<p>Inbound Transitions:</p>
	<ul>
		<li>IDLE</li>
</ul>
<p>Outbound Transitions:</p>
	<ul>
		<li>IN_SESSION</li>
</ul>
<p>Events Handled (3 of 4 for 75%):</p>
	<ul>
		<li>SESSION_ESTABLISHED</li>
		<li>MESSAGE_RECEIVED</li>
		<li>SEND_MESSAGE</li>
	</ul>
<p>Actions Taken:
</p>
	<ul>
		<li>completeSessionStart</li>
		<li>passMessageReceived</li>
		<li>queueMessage</li>
	</ul>
</td></tr>
<tr>
<td class='label'>IN_SESSION</td>
<td>
<p> A session has been established, and messages are being exchanged with the peer.  While in this
        state, the <i>MESSAGE_RECEIVED</i> event is forwarded to the <i>sendMessage</i> submachine.
    </p>
<p>Inbound Transitions:</p>
	<ul>
		<li>ESTABLISHING_SESSION</li>
</ul>
<p>Outbound Transitions:</p>
	<ul>
		<li>IDLE</li>
</ul>
<p>Events Handled (3 of 4 for 75%):</p>
	<ul>
		<li>MESSAGE_RECEIVED</li>
		<li>SEND_MESSAGE</li>
		<li>SESSION_TIMEOUT</li>
	</ul>
<p>Actions Taken:
</p>
	<ul>
		<li>passMessageReceived</li>
		<li>requestMessageTransmission</li>
	</ul>
</td></tr>
</tbody>
</table>
<table class="elements">
<thead><tr>
<th colspan=2 align=left>Actions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="label">startSessionEstablishment</td>
<td>

<br/><br/>Shares event to:<ul class="return_decl"><li>sendMessage</li>
</ul>
<p>Matrices:</p>
	<ul>
		<li>SEND_MESSAGE, IDLE transitions to state ESTABLISHING_SESSION		</li>	</ul>
</td>
</tr>
<tr>
<td class="label">completeSessionStart</td>
<td>

<br/><br/>Returns:<ul class="return_decl">		<li>noEvent</li>
</ul>
<p>Matrices:</p>
	<ul>
		<li>SESSION_ESTABLISHED, ESTABLISHING_SESSION transitions to state IN_SESSION		</li>	</ul>
</td>
</tr>
<tr>
<td class="label">passMessageReceived</td>
<td>

<br/><br/>Shares event to:<ul class="return_decl"><li>establishSession</li>
<li>sendMessage</li>
</ul>
<p>Matrices:</p>
	<ul>
		<li>MESSAGE_RECEIVED, (ESTABLISHING_SESSION, IN_SESSION)		</li>	</ul>
</td>
</tr>
<tr>
<td class="label">queueMessage</td>
<td>

<br/><br/>Shares event to:<ul class="return_decl"><li>sendMessage</li>
</ul>
<p>Matrices:</p>
	<ul>
		<li>SEND_MESSAGE, ESTABLISHING_SESSION		</li>	</ul>
</td>
</tr>
<tr>
<td class="label">requestMessageTransmission</td>
<td>

<br/><br/>Shares event to:<ul class="return_decl"><li>sendMessage</li>
</ul>
<p>Matrices:</p>
	<ul>
		<li>SEND_MESSAGE, IN_SESSION		</li>	</ul>
</td>
</tr>
<tr>
<td class="label">transition</td>
<td>
<p>Matrices:</p>
	<ul>
		<li>SESSION_TIMEOUT, IN_SESSION transitions to state IDLE		</li>	</ul>
</td>
</tr>
</tbody>
</table>
<table class="elements">
<thead><tr>
<th colspan=2 align=left>Sub Machines</th>
</tr>
</thead>
<tbody>
<tr>
<td class="label"><a href="establishSession.html" target="FSMLang-establishSession">establishSession</a></td>
<td>


    Establish a connection with the peer.
    

    Two messages must be exchanged with the peer to successfully establish the session.  The machine needs
    only two states, IDLE and AWAITING_RESPONSE since the top level machine tracks whether or not it is in a
    session.  The AWAITING_RESPONSE state serves for both required messages, since the receipt of each message produces
    a unique event.
    

    When the STEP1_RESPONSE event is received, the session is considered established.  This machine will then
    return the parent's SESSION_ESTABLISHED message and move to its IDLE state.
    
    </td>
</tr>
<tr>
<td class="label"><a href="sendMessage.html" target="FSMLang-sendMessage">sendMessage</a></td>
<td>


    Send a message to the peer.
    

    Since the protocol allows only one message to be outsanding, the machine dequeues and transmits a message only
    from the IDLE state, transitioning to the AWAITING_ACK state immediately thereafter.
    

    In the AWAITNG_ACK state, incomming messages are parsed and, when an ACK is found, the machine checks the queue
    and transitions to the IDLE state.  Checking the queue can return the SEND_MESSAGE event, which will be handled
    from the IDLE state, thus resulting in a transmission and return to the AWAITING_ACK state.
    

    </td>
</tr>
</tbody>
</table>
</body>
</html>
