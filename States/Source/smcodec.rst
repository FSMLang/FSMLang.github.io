=============
sendMessage.c
=============

.. code-block:: c

	/**
		sendMessage.c
	
		This file automatically generated by FSMLang
	*/
	
	#include "sendMessage_priv.h"
	#include <stddef.h>
	
	/* Begin Native Implementation Prolog */
	
	
	#define INIT_FSM_DATA {msg_none, NULL}
	
	/* End Native Implementation Prolog */
	
	
	#ifndef DBG_PRINTF
	#define DBG_PRINTF(...)
	#endif
	
	static HSM_COMMUNICATOR_EVENT_ENUM sendMessageFSM(FSM_TYPE_PTR,HSM_COMMUNICATOR_EVENT_ENUM);
	
	static HSM_COMMUNICATOR_EVENT_ENUM UNINITIALIZED_stateFn(pSEND_MESSAGE,HSM_COMMUNICATOR_EVENT_ENUM);
	static HSM_COMMUNICATOR_EVENT_ENUM IDLE_stateFn(pSEND_MESSAGE,HSM_COMMUNICATOR_EVENT_ENUM);
	static HSM_COMMUNICATOR_EVENT_ENUM AWAITING_ACK_stateFn(pSEND_MESSAGE,HSM_COMMUNICATOR_EVENT_ENUM);
	
	static const SEND_MESSAGE_STATE_FN sendMessage_state_fn_array[sendMessage_numStates] =
	{
	    UNINITIALIZED_stateFn
	    , IDLE_stateFn
	    , AWAITING_ACK_stateFn
	};
	
	HSM_COMMUNICATOR_EVENT_ENUM THIS(sub_machine_fn)(HSM_COMMUNICATOR_EVENT_ENUM e)
	{
	    return sendMessageFSM(psendMessage,e);
	}
	
	HSM_COMMUNICATOR_SUB_FSM_IF hsmCommunicator_sendMessage_sub_fsm_if =
	{
	    .subFSM = THIS(sub_machine_fn)
	    , .first_event = THIS(firstEvent)
	    , .last_event = THIS(noEvent)
	};
	
	HSM_COMMUNICATOR_SHARED_EVENT_STR sendMessage_share_hsmCommunicator_INIT_str = {
	    .event               = THIS(INIT)
	    , .data_translation_fn = UFMN(init_data)
	    , .psub_fsm_if         = &hsmCommunicator_sendMessage_sub_fsm_if
	};
	
	HSM_COMMUNICATOR_SHARED_EVENT_STR sendMessage_share_hsmCommunicator_MESSAGE_RECEIVED_str = {
	    .event               = THIS(MESSAGE_RECEIVED)
	    , .data_translation_fn = UFMN(copy_current_message)
	    , .psub_fsm_if         = &hsmCommunicator_sendMessage_sub_fsm_if
	};
	
	#ifndef INIT_FSM_DATA
	#error INIT_FSM_DATA must be defined
	#endif
	
	SEND_MESSAGE sendMessage = {
	
	    INIT_FSM_DATA,
	    sendMessage_UNINITIALIZED,
	    THIS(INIT),
	    &sendMessage_state_fn_array,
	    sendMessageFSM
	};
	
	pSEND_MESSAGE psendMessage = &sendMessage;
	
	
	#ifndef EVENT_IS_NOT_EXCLUDED_FROM_LOG
	#define EVENT_IS_NOT_EXCLUDED_FROM_LOG(e) (e == e)
	#endif
	HSM_COMMUNICATOR_EVENT_ENUM sendMessageFSM(pSEND_MESSAGE pfsm, HSM_COMMUNICATOR_EVENT_ENUM event)
	{
	    HSM_COMMUNICATOR_EVENT_ENUM e = event;
	
	    while ((e != THIS(noEvent))
	            && (e >= THIS(firstEvent))
	          )
	    {
	
	#ifdef HSM_COMMUNICATOR_SEND_MESSAGE_DEBUG
	        if ((EVENT_IS_NOT_EXCLUDED_FROM_LOG(e))
	                && (e >= THIS(firstEvent))
	                && (e < THIS(noEvent))
	           )
	        {
	            DBG_PRINTF("event: %s; state: %s"
	                       ,SEND_MESSAGE_EVENT_NAMES[e - THIS(firstEvent)]
	                       ,SEND_MESSAGE_STATE_NAMES[pfsm->state]
	                      );
	        }
	#endif
	
	        /* This is read-only data to facilitate error reporting in action functions */
	        pfsm->event = e;
	
	        if ((e >= THIS(firstEvent))
	                && (e < THIS(noEvent))
	           )
	        {
	            e = ((* (*pfsm->statesArray)[pfsm->state])(pfsm,e));
	        }
	
	    }
	
	    return e == THIS(noEvent) ? PARENT(noEvent) : e;
	}
	
	static HSM_COMMUNICATOR_EVENT_ENUM UNINITIALIZED_stateFn(pSEND_MESSAGE pfsm,HSM_COMMUNICATOR_EVENT_ENUM e)
	{
	    HSM_COMMUNICATOR_EVENT_ENUM retVal = THIS(noEvent);
	
	    switch(e)
	    {
	    case THIS(INIT):
	        DBG_PRINTF("hsmCommunicator_sendMessage_noAction");
	        pfsm->state = sendMessage_IDLE;
	        break;
	    default:
	        DBG_PRINTF("hsmCommunicator_sendMessage_noAction");
	        break;
	    }
	
	    return retVal;
	}
	
	static HSM_COMMUNICATOR_EVENT_ENUM IDLE_stateFn(pSEND_MESSAGE pfsm,HSM_COMMUNICATOR_EVENT_ENUM e)
	{
	    HSM_COMMUNICATOR_EVENT_ENUM retVal = THIS(noEvent);
	
	    switch(e)
	    {
	    case THIS(SEND_MESSAGE):
	        retVal = UFMN(sendMessage)(pfsm);
	        pfsm->state = sendMessage_AWAITING_ACK;
	        break;
	    default:
	        DBG_PRINTF("hsmCommunicator_sendMessage_noAction");
	        break;
	    }
	
	    return retVal;
	}
	
	static HSM_COMMUNICATOR_EVENT_ENUM AWAITING_ACK_stateFn(pSEND_MESSAGE pfsm,HSM_COMMUNICATOR_EVENT_ENUM e)
	{
	    HSM_COMMUNICATOR_EVENT_ENUM retVal = THIS(noEvent);
	
	    switch(e)
	    {
	    case THIS(ACK):
	        retVal = UFMN(checkQueue)(pfsm);
	        pfsm->state = sendMessage_IDLE;
	        break;
	    case THIS(MESSAGE_RECEIVED):
	        retVal = UFMN(parseMessage)(pfsm);
	        break;
	    default:
	        DBG_PRINTF("hsmCommunicator_sendMessage_noAction");
	        break;
	    }
	
	    return retVal;
	}
	
	
	
	#ifdef HSM_COMMUNICATOR_SEND_MESSAGE_DEBUG
	char *SEND_MESSAGE_EVENT_NAMES[] = {
	    "hsmCommunicator_sendMessage_INIT"
	    ,"hsmCommunicator_sendMessage_MESSAGE_RECEIVED"
	    ,"hsmCommunicator_sendMessage_SEND_MESSAGE"
	    ,"hsmCommunicator_sendMessage_ACK"
	    , "sendMessage_noEvent"
	    , "sendMessage_numEvents"
	};
	
	char *SEND_MESSAGE_STATE_NAMES[] = {
	    "hsmCommunicator_sendMessage_UNINITIALIZED"
	    ,"hsmCommunicator_sendMessage_IDLE"
	    ,"hsmCommunicator_sendMessage_AWAITING_ACK"
	};
	
	#endif
	
