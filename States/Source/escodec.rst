==================
establishSession.c
==================

.. code-block:: c

	/**
		establishSession.c
	
		This file automatically generated by FSMLang
	*/
	
	#include "establishSession_priv.h"
	#include <stddef.h>
	
	/* Begin Native Implementation Prolog */
	
	
	#define INIT_FSM_DATA {msg_none}
	
	/* End Native Implementation Prolog */
	
	
	#ifndef DBG_PRINTF
	#define DBG_PRINTF(...)
	#endif
	
	static HSM_COMMUNICATOR_EVENT_ENUM establishSessionFSM(FSM_TYPE_PTR,HSM_COMMUNICATOR_EVENT_ENUM);
	
	static HSM_COMMUNICATOR_EVENT_ENUM IDLE_stateFn(pESTABLISH_SESSION,HSM_COMMUNICATOR_EVENT_ENUM);
	static HSM_COMMUNICATOR_EVENT_ENUM AWAITING_RESPONSE_stateFn(pESTABLISH_SESSION,HSM_COMMUNICATOR_EVENT_ENUM);
	
	static const ESTABLISH_SESSION_STATE_FN establishSession_state_fn_array[establishSession_numStates] =
	{
	    IDLE_stateFn
	    , AWAITING_RESPONSE_stateFn
	};
	
	HSM_COMMUNICATOR_EVENT_ENUM THIS(sub_machine_fn)(HSM_COMMUNICATOR_EVENT_ENUM e)
	{
	    return establishSessionFSM(pestablishSession,e);
	}
	
	HSM_COMMUNICATOR_SUB_FSM_IF hsmCommunicator_establishSession_sub_fsm_if =
	{
	    .subFSM = THIS(sub_machine_fn)
	    , .first_event = THIS(firstEvent)
	    , .last_event = THIS(noEvent)
	};
	
	HSM_COMMUNICATOR_SHARED_EVENT_STR establishSession_share_hsmCommunicator_MESSAGE_RECEIVED_str = {
	    .event               = THIS(MESSAGE_RECEIVED)
	    , .data_translation_fn = UFMN(copy_current_message)
	    , .psub_fsm_if         = &hsmCommunicator_establishSession_sub_fsm_if
	};
	
	#ifndef INIT_FSM_DATA
	#error INIT_FSM_DATA must be defined
	#endif
	
	ESTABLISH_SESSION establishSession = {
	
	    INIT_FSM_DATA,
	    establishSession_IDLE,
	    THIS(ESTABLISH_SESSION_REQUEST),
	    &establishSession_state_fn_array,
	    establishSessionFSM
	};
	
	pESTABLISH_SESSION pestablishSession = &establishSession;
	
	
	#ifndef EVENT_IS_NOT_EXCLUDED_FROM_LOG
	#define EVENT_IS_NOT_EXCLUDED_FROM_LOG(e) (e == e)
	#endif
	HSM_COMMUNICATOR_EVENT_ENUM establishSessionFSM(pESTABLISH_SESSION pfsm, HSM_COMMUNICATOR_EVENT_ENUM event)
	{
	    HSM_COMMUNICATOR_EVENT_ENUM e = event;
	
	    while ((e != THIS(noEvent))
	            && (e >= THIS(firstEvent))
	          )
	    {
	
	#ifdef HSM_COMMUNICATOR_ESTABLISH_SESSION_DEBUG
	        if ((EVENT_IS_NOT_EXCLUDED_FROM_LOG(e))
	                && (e >= THIS(firstEvent))
	                && (e < THIS(noEvent))
	           )
	        {
	            DBG_PRINTF("event: %s; state: %s"
	                       ,ESTABLISH_SESSION_EVENT_NAMES[e - THIS(firstEvent)]
	                       ,ESTABLISH_SESSION_STATE_NAMES[pfsm->state]
	                      );
	        }
	#endif
	
	        /* This is read-only data to facilitate error reporting in action functions */
	        pfsm->event = e;
	
	        if ((e >= THIS(firstEvent))
	                && (e < THIS(noEvent))
	           )
	        {
	            e = ((* (*pfsm->statesArray)[pfsm->state])(pfsm,e));
	        }
	
	    }
	
	    return e == THIS(noEvent) ? PARENT(noEvent) : e;
	}
	
	static HSM_COMMUNICATOR_EVENT_ENUM IDLE_stateFn(pESTABLISH_SESSION pfsm,HSM_COMMUNICATOR_EVENT_ENUM e)
	{
	    HSM_COMMUNICATOR_EVENT_ENUM retVal = THIS(noEvent);
	
	    switch(e)
	    {
	    case THIS(ESTABLISH_SESSION_REQUEST):
	        retVal = UFMN(sendStep0Message)(pfsm);
	        pfsm->state = establishSession_AWAITING_RESPONSE;
	        break;
	    default:
	        DBG_PRINTF("hsmCommunicator_establishSession_noAction");
	        break;
	    }
	
	    return retVal;
	}
	
	static HSM_COMMUNICATOR_EVENT_ENUM AWAITING_RESPONSE_stateFn(pESTABLISH_SESSION pfsm,HSM_COMMUNICATOR_EVENT_ENUM e)
	{
	    HSM_COMMUNICATOR_EVENT_ENUM retVal = THIS(noEvent);
	
	    switch(e)
	    {
	    case THIS(STEP0_RESPONSE):
	        retVal = UFMN(sendStep1Message)(pfsm);
	        break;
	    case THIS(MESSAGE_RECEIVED):
	        retVal = UFMN(parseMessage)(pfsm);
	        pfsm->state = UFMN(decide_parse_transition)(pfsm,e);
	        break;
	    default:
	        DBG_PRINTF("hsmCommunicator_establishSession_noAction");
	        break;
	    }
	
	    return retVal;
	}
	
	
	
	#ifdef HSM_COMMUNICATOR_ESTABLISH_SESSION_DEBUG
	char *ESTABLISH_SESSION_EVENT_NAMES[] = {
	    "hsmCommunicator_establishSession_ESTABLISH_SESSION_REQUEST"
	    ,"hsmCommunicator_establishSession_STEP0_RESPONSE"
	    ,"hsmCommunicator_establishSession_MESSAGE_RECEIVED"
	    , "establishSession_noEvent"
	    , "establishSession_numEvents"
	};
	
	char *ESTABLISH_SESSION_STATE_NAMES[] = {
	    "hsmCommunicator_establishSession_IDLE"
	    ,"hsmCommunicator_establishSession_AWAITING_RESPONSE"
	};
	
	#endif

