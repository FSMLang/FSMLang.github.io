====================
simpleCommunicator.c
====================

Generated using ``fsm -te simpleCommunicator.fsm``

.. code-block:: c

	/**
		simpleCommunicator.c
	
		This file automatically generated by FSMLang
	*/
	
	#include "simpleCommunicator_priv.h"
	#include <stddef.h>
	
	
	#ifndef DBG_PRINTF
	#define DBG_PRINTF(...)
	#endif
	
	static ACTION_RETURN_TYPE simpleCommunicator_handle_SEND_MESSAGE(FSM_TYPE_PTR);
	static ACTION_RETURN_TYPE simpleCommunicator_handle_ACK(FSM_TYPE_PTR);
	
	static const SIMPLE_COMMUNICATOR_ACTION_FN simpleCommunicator_event_fn_array[simpleCommunicator_numMachineEvents] =
	{
	    simpleCommunicator_handle_SEND_MESSAGE
	    , simpleCommunicator_handle_ACK
	};
	
	SIMPLE_COMMUNICATOR simpleCommunicator = {
	    simpleCommunicator_IDLE,
	    THIS(SEND_MESSAGE),
	    &simpleCommunicator_event_fn_array,
	    simpleCommunicatorFSM
	};
	
	pSIMPLE_COMMUNICATOR psimpleCommunicator = &simpleCommunicator;
	
	void run_simpleCommunicator(SIMPLE_COMMUNICATOR_EVENT e)
	{
	    if (psimpleCommunicator)
	    {
	        psimpleCommunicator->fsm(psimpleCommunicator,e);
	    }
	}
	
	
	#ifndef EVENT_IS_NOT_EXCLUDED_FROM_LOG
	#define EVENT_IS_NOT_EXCLUDED_FROM_LOG(e) ((e) == (e))
	#endif
	void simpleCommunicatorFSM(pSIMPLE_COMMUNICATOR pfsm, SIMPLE_COMMUNICATOR_EVENT event)
	{
	    SIMPLE_COMMUNICATOR_EVENT e = event;
	
	    while (e != simpleCommunicator_noEvent) {
	
	#ifdef SIMPLE_COMMUNICATOR_DEBUG
	        if (EVENT_IS_NOT_EXCLUDED_FROM_LOG(e))
	        {
	            DBG_PRINTF("event: %s; state: %s"
	                       ,SIMPLE_COMMUNICATOR_EVENT_NAMES[e]
	                       ,SIMPLE_COMMUNICATOR_STATE_NAMES[pfsm->state]
	                      );
	        }
	#endif
	
	        /* This is read-only data to facilitate error reporting in action functions */
	        pfsm->event = e;
	
	        e = ((* (*pfsm->eventsArray)[e])(pfsm));
	    }
	
	}
	
	static ACTION_RETURN_TYPE simpleCommunicator_handle_SEND_MESSAGE(FSM_TYPE_PTR pfsm)
	{
	    ACTION_RETURN_TYPE event = THIS(noEvent);
	
	    switch (pfsm->state)
	    {
	    case STATE(IDLE):
	        event = UFMN(sendMessage)(pfsm);
	        pfsm->state = STATE(AWAITING_ACK);
	        break;
	    case STATE(AWAITING_ACK):
	        event = UFMN(queueMessage)(pfsm);
	        break;
	    }
	
	    return event;
	}
	
	static ACTION_RETURN_TYPE simpleCommunicator_handle_ACK(FSM_TYPE_PTR pfsm)
	{
	    ACTION_RETURN_TYPE event = THIS(noEvent);
	
	    switch (pfsm->state)
	    {
	    case STATE(AWAITING_ACK):
	        event = UFMN(checkQueue)(pfsm);
	        pfsm->state = STATE(IDLE);
	        break;
	    default:
	        DBG_PRINTF("simpleCommunicator_noAction");
	        break;
	    }
	
	    return event;
	}
	
	SIMPLE_COMMUNICATOR_EVENT __attribute__((weak)) UFMN(sendMessage)(FSM_TYPE_PTR pfsm)
	{
	    DBG_PRINTF("weak: %s", __func__);
	    (void) pfsm;
	    return THIS(noEvent);
	}
	
	SIMPLE_COMMUNICATOR_EVENT __attribute__((weak)) UFMN(queueMessage)(FSM_TYPE_PTR pfsm)
	{
	    DBG_PRINTF("weak: %s", __func__);
	    (void) pfsm;
	    return THIS(noEvent);
	}
	
	SIMPLE_COMMUNICATOR_EVENT __attribute__((weak)) UFMN(checkQueue)(FSM_TYPE_PTR pfsm)
	{
	    DBG_PRINTF("weak: %s", __func__);
	    (void) pfsm;
	    return THIS(noEvent);
	}
	
	
	#ifdef SIMPLE_COMMUNICATOR_DEBUG
	char *SIMPLE_COMMUNICATOR_EVENT_NAMES[] = {
	    "simpleCommunicator_SEND_MESSAGE"
	    ,"simpleCommunicator_ACK"
	    , "simpleCommunicator_noEvent"
	    , "simpleCommunicator_numEvents"
	};
	
	char *SIMPLE_COMMUNICATOR_STATE_NAMES[] = {
	    "simpleCommunicator_IDLE"
	    ,"simpleCommunicator_AWAITING_ACK"
	};
	
	#endif
	
