/**
	simpleCommunicator.c

	This file automatically generated by FSMLang
*/

#include "simpleCommunicator_priv.h"
#include <stddef.h>


#ifndef DBG_PRINTF
#define DBG_PRINTF(...)
#endif

static SIMPLE_COMMUNICATOR_EVENT IDLE_stateFn(pSIMPLE_COMMUNICATOR,SIMPLE_COMMUNICATOR_EVENT);
static SIMPLE_COMMUNICATOR_EVENT AWAITING_ACK_stateFn(pSIMPLE_COMMUNICATOR,SIMPLE_COMMUNICATOR_EVENT);
static const SIMPLE_COMMUNICATOR_STATE_FN simpleCommunicator_state_fn_array[simpleCommunicator_numStates] =
{
    IDLE_stateFn
    , AWAITING_ACK_stateFn
};

SIMPLE_COMMUNICATOR simpleCommunicator = {
    simpleCommunicator_IDLE,
    THIS(SEND_MESSAGE),
    &simpleCommunicator_state_fn_array,
    simpleCommunicatorFSM
};

pSIMPLE_COMMUNICATOR psimpleCommunicator = &simpleCommunicator;

void run_simpleCommunicator(SIMPLE_COMMUNICATOR_EVENT e)
{
    if (psimpleCommunicator)
    {
        psimpleCommunicator->fsm(psimpleCommunicator,e);
    }
}


#ifndef EVENT_IS_NOT_EXCLUDED_FROM_LOG
#define EVENT_IS_NOT_EXCLUDED_FROM_LOG(e) ((e) == (e))
#endif
void simpleCommunicatorFSM(pSIMPLE_COMMUNICATOR pfsm, SIMPLE_COMMUNICATOR_EVENT event)
{
    SIMPLE_COMMUNICATOR_EVENT e = event;

    while (e != simpleCommunicator_noEvent) {

#ifdef SIMPLE_COMMUNICATOR_DEBUG
        if (EVENT_IS_NOT_EXCLUDED_FROM_LOG(e))
        {
            DBG_PRINTF("event: %s; state: %s"
                       ,SIMPLE_COMMUNICATOR_EVENT_NAMES[e]
                       ,SIMPLE_COMMUNICATOR_STATE_NAMES[pfsm->state]
                      );
        }
#endif

        /* This is read-only data to facilitate error reporting in action functions */
        pfsm->event = e;

        e = ((* (*pfsm->statesArray)[pfsm->state])(pfsm,e));
    }

}

static SIMPLE_COMMUNICATOR_EVENT IDLE_stateFn(pSIMPLE_COMMUNICATOR pfsm,SIMPLE_COMMUNICATOR_EVENT e)
{
    SIMPLE_COMMUNICATOR_EVENT retVal = THIS(noEvent);

    switch(e)
    {
    case THIS(SEND_MESSAGE):
        retVal = UFMN(sendMessage)(pfsm);
        pfsm->state = simpleCommunicator_AWAITING_ACK;
        break;
    default:
        DBG_PRINTF("simpleCommunicator_noAction");
        break;
    }

    return retVal;
}

static SIMPLE_COMMUNICATOR_EVENT AWAITING_ACK_stateFn(pSIMPLE_COMMUNICATOR pfsm,SIMPLE_COMMUNICATOR_EVENT e)
{
    SIMPLE_COMMUNICATOR_EVENT retVal = THIS(noEvent);

    switch(e)
    {
    case THIS(SEND_MESSAGE):
        retVal = UFMN(queueMessage)(pfsm);
        break;
    case THIS(ACK):
        retVal = UFMN(checkQueue)(pfsm);
        pfsm->state = simpleCommunicator_IDLE;
        break;
    default:
        DBG_PRINTF("simpleCommunicator_noAction");
        break;
    }

    return retVal;
}


SIMPLE_COMMUNICATOR_EVENT __attribute__((weak)) UFMN(sendMessage)(FSM_TYPE_PTR pfsm)
{
    DBG_PRINTF("weak: %s", __func__);
    (void) pfsm;
    return THIS(noEvent);
}

SIMPLE_COMMUNICATOR_EVENT __attribute__((weak)) UFMN(queueMessage)(FSM_TYPE_PTR pfsm)
{
    DBG_PRINTF("weak: %s", __func__);
    (void) pfsm;
    return THIS(noEvent);
}

SIMPLE_COMMUNICATOR_EVENT __attribute__((weak)) UFMN(checkQueue)(FSM_TYPE_PTR pfsm)
{
    DBG_PRINTF("weak: %s", __func__);
    (void) pfsm;
    return THIS(noEvent);
}


#ifdef SIMPLE_COMMUNICATOR_DEBUG
char *SIMPLE_COMMUNICATOR_EVENT_NAMES[] = {
    "simpleCommunicator_SEND_MESSAGE"
    ,"simpleCommunicator_ACK"
    , "simpleCommunicator_noEvent"
    , "simpleCommunicator_numEvents"
};

char *SIMPLE_COMMUNICATOR_STATE_NAMES[] = {
    "simpleCommunicator_IDLE"
    ,"simpleCommunicator_AWAITING_ACK"
};

#endif
