..
   sendMessage.rst

   This file automatically generated by FSMLang

============
sendMessage
============

Send a message to the peer.
Since the protocol allows only one message to be 
outsanding, the machine dequeues and transmits a message only
from the IDLE 
state, transitioning to the AWAITING_ACK state immediately thereafter.
In the 
AWAITNG_ACK state, incomming messages are parsed and, when an ACK is found, 
the machine checks the queue
and transitions to the IDLE state. Checking the 
queue can return the SEND_MESSAGE event, which will be handled
from the IDLE 
state, thus resulting in a transmission and return to the AWAITING_ACK state.




.. list-table:: Machine Statistics
   :align: left

   * - Number of events:
     - 3
   * - Events not handled:
     - 0
   * - Events handled in one state:
     - 3
   * - At least one event handled the same in all states?
     - no
   * - Number of states:
     - 2
   * - Number of states with entry functions:
     - 0
   * - Number of states with exit functions:
     - 0
   * - States handling no events:
     - 0
   * - States handling exactly one event:
     - 1
   * - States with no way in:
     - 0
   * - States with no way out:
     - 0



.. list-table:: State Chart
   :align: left
   :header-rows: 1
   :stub-columns: 1
   :class: scrollable

   * -
     - :ref:`SEND_MESSAGE <hsmCommunicator.sendMessage.SEND_MESSAGE>`
     - :ref:`MESSAGE_RECEIVED <hsmCommunicator.sendMessage.MESSAGE_RECEIVED>`
     - :ref:`ACK <hsmCommunicator.sendMessage.ACK>`
   * - :ref:`IDLE <hsmCommunicator.sendMessage.IDLE>`
     - | :ref:`sendMessage <hsmCommunicator.sendMessage.sendMessage>`
       | transition: :ref:`AWAITING_ACK <hsmCommunicator.sendMessage.AWAITING_ACK>`
     - 
     - 
   * - :ref:`AWAITING_ACK <hsmCommunicator.sendMessage.AWAITING_ACK>`
     - 
     - :ref:`parseMessage <hsmCommunicator.sendMessage.parseMessage>`
     - | :ref:`checkQueue <hsmCommunicator.sendMessage.checkQueue>`
       | transition: :ref:`IDLE <hsmCommunicator.sendMessage.IDLE>`


Events
-------


.. _hsmCommunicator.sendMessage.SEND_MESSAGE:

SEND_MESSAGE
~~~~~~~~~~~~~

This event is shared from the parent machine.



This event is handled identically in 1 states.



These states handle this event:

* :ref:`IDLE <hsmCommunicator.sendMessage.IDLE>`


This yields a state density of 50%.



These actions are taken in response to this event:

* :ref:`sendMessage <hsmCommunicator.sendMessage.sendMessage>`


.. _hsmCommunicator.sendMessage.MESSAGE_RECEIVED:

MESSAGE_RECEIVED
~~~~~~~~~~~~~~~~~

This event is shared from the parent machine.



This event is handled identically in 1 states.



These states handle this event:

* :ref:`AWAITING_ACK <hsmCommunicator.sendMessage.AWAITING_ACK>`


This yields a state density of 50%.



These actions are taken in response to this event:

* :ref:`parseMessage <hsmCommunicator.sendMessage.parseMessage>`


.. _hsmCommunicator.sendMessage.ACK:

ACK
~~~~

This event is handled identically in 1 states.



These states handle this event:

* :ref:`AWAITING_ACK <hsmCommunicator.sendMessage.AWAITING_ACK>`


This yields a state density of 50%.



These actions are taken in response to this event:

* :ref:`checkQueue <hsmCommunicator.sendMessage.checkQueue>`


States
-------


.. _hsmCommunicator.sendMessage.IDLE:

IDLE
~~~~~

These events are handled in this state:

* :ref:`SEND_MESSAGE <hsmCommunicator.SEND_MESSAGE>`


This yields an event density of 33%.



These actions are taken in this state:

* :ref:`sendMessage <hsmCommunicator.sendMessage.sendMessage>`


These states transition into this state:

* :ref:`AWAITING_ACK <hsmCommunicator.sendMessage.AWAITING_ACK>`


This state transitions into these states:

* :ref:`AWAITING_ACK <hsmCommunicator.sendMessage.AWAITING_ACK>`


.. _hsmCommunicator.sendMessage.AWAITING_ACK:

AWAITING_ACK
~~~~~~~~~~~~~

These events are handled in this state:

* :ref:`ACK <hsmCommunicator.sendMessage.ACK>`
* :ref:`MESSAGE_RECEIVED <hsmCommunicator.MESSAGE_RECEIVED>`


This yields an event density of 66%.



These actions are taken in this state:

* :ref:`checkQueue <hsmCommunicator.sendMessage.checkQueue>`
* :ref:`parseMessage <hsmCommunicator.sendMessage.parseMessage>`


These states transition into this state:

* :ref:`IDLE <hsmCommunicator.sendMessage.IDLE>`


This state transitions into these states:

* :ref:`IDLE <hsmCommunicator.sendMessage.IDLE>`


Actions
--------


.. _hsmCommunicator.sendMessage.sendMessage:

sendMessage
~~~~~~~~~~~~

Send a message to the peer.
Since the protocol allows only one message to be 
outsanding, the machine dequeues and transmits a message only
from the IDLE 
state, transitioning to the AWAITING_ACK state immediately thereafter.
In the 
AWAITNG_ACK state, incomming messages are parsed and, when an ACK is found, 
the machine checks the queue
and transitions to the IDLE state. Checking the 
queue can return the SEND_MESSAGE event, which will be handled
from the IDLE 
state, thus resulting in a transmission and return to the AWAITING_ACK state.




This action returns:

* noEvent



.. _hsmCommunicator.sendMessage.checkQueue:

checkQueue
~~~~~~~~~~~

This action returns:

* :ref:`SEND_MESSAGE <hsmCommunicator.SEND_MESSAGE>`
* noEvent



.. _hsmCommunicator.sendMessage.parseMessage:

parseMessage
~~~~~~~~~~~~~

This action returns:

* :ref:`ACK <hsmCommunicator.sendMessage.ACK>`
* noEvent

