<html>
<head>
    <title>sendMessage.c</title>
</head>
<body>
<pre>
/**
	sendMessage.c

	This file automatically generated by FSMLang
*/

#include "sendMessage.h"


const SEND_MESSAGE_ACTION_TRANS sendMessage_action_array[sendMessage_numEvents][sendMessage_numStates] =
{
	{
		/* -- SEND_MESSAGE -- */

		/* -- IDLE -- */	{sendMessage_queueMessage,sendMessage_IDLE}
		/* -- IN_SESSION -- */	, {sendMessage_sendMessage,sendMessage_AWAITING_ACK}
		/* -- AWAITING_ACK -- */	, {sendMessage_queueMessage,sendMessage_AWAITING_ACK}
	},
	{
		/* -- ACK -- */

		/* -- IDLE -- */	{sendMessage_noAction, sendMessage_IDLE}
		/* -- IN_SESSION -- */	, {sendMessage_noAction, sendMessage_IN_SESSION}
		/* -- AWAITING_ACK -- */	, {sendMessage_checkQueue,sendMessage_IN_SESSION}
	},
	{
		/* -- SESSION_ESTABLISHED -- */

		/* -- IDLE -- */	{sendMessage_checkQueue,sendMessage_IN_SESSION}
		/* -- IN_SESSION -- */	, {sendMessage_noAction, sendMessage_IN_SESSION}
		/* -- AWAITING_ACK -- */	, {sendMessage_noAction, sendMessage_AWAITING_ACK}
	},
	{
		/* -- SESSION_TIMEOUT -- */

		/* -- IDLE -- */	{sendMessage_noAction, sendMessage_IDLE}
		/* -- IN_SESSION -- */	, {sendMessage_noAction,sendMessage_IDLE}
		/* -- AWAITING_ACK -- */	, {sendMessage_noAction,sendMessage_IDLE}
	},
};
HSM_COMMUNICATOR_EVENT sendMessage_sub_machine_fn(HSM_COMMUNICATOR_EVENT e)
{
	return sendMessageFSM(psendMessage, e);
}


HSM_COMMUNICATOR_SUB_FSM_IF sendMessage_sub_fsm_if =
{
		.subFSM = sendMessage_sub_machine_fn
	, .first_event = hsmCommunicator_sendMessage_SEND_MESSAGE
	, .last_event = hsmCommunicator_sendMessage_SESSION_TIMEOUT
};

SEND_MESSAGE sendMessage = {
	sendMessage_IDLE,
	&sendMessage_action_array,
	sendMessageFSM
};

pSEND_MESSAGE psendMessage = &sendMessage;

HSM_COMMUNICATOR_EVENT sendMessageFSM(pSEND_MESSAGE pfsm, HSM_COMMUNICATOR_EVENT event)
{
/* writeOriginalSubFSM */
	HSM_COMMUNICATOR_EVENT new_e;

	HSM_COMMUNICATOR_EVENT e = event;

	while (
		(e != THIS(noEvent))
		&& (e >= THIS(SEND_MESSAGE))
	)
	{

#ifdef SEND_MESSAGE_DEBUG
DBG_PRINTF("event: %s; state: %s"
,SEND_MESSAGE_EVENT_NAMES[e - THIS(SEND_MESSAGE)]
,SEND_MESSAGE_STATE_NAMES[pfsm->state]
);
#endif

		new_e = ((* (*pfsm->actionArray)[e - THIS(SEND_MESSAGE)][pfsm->state].action)(pfsm));

		pfsm->state = (*pfsm->actionArray)[e - THIS(SEND_MESSAGE)][pfsm->state].transition;

		e = new_e;

	} 
	return e == THIS(noEvent) ? PARENT(noEvent) : e;

}

HSM_COMMUNICATOR_EVENT __attribute__((weak)) sendMessage_sendMessage(pSEND_MESSAGE pfsm)
{
	DBG_PRINTF("weak: sendMessage_sendMessage");
	return THIS(noEvent);
}

HSM_COMMUNICATOR_EVENT __attribute__((weak)) sendMessage_queueMessage(pSEND_MESSAGE pfsm)
{
	DBG_PRINTF("weak: sendMessage_queueMessage");
	return THIS(noEvent);
}

HSM_COMMUNICATOR_EVENT __attribute__((weak)) sendMessage_checkQueue(pSEND_MESSAGE pfsm)
{
	DBG_PRINTF("weak: sendMessage_checkQueue");
	return THIS(noEvent);
}


#ifdef SEND_MESSAGE_DEBUG
char *SEND_MESSAGE_EVENT_NAMES[] = {
	 "sendMessage_SEND_MESSAGE"
	, "sendMessage_ACK"
	, "sendMessage_SESSION_ESTABLISHED"
	, "sendMessage_SESSION_TIMEOUT"
	, "sendMessage_noEvent"
	, "sendMessage_numEvents"
};

char *SEND_MESSAGE_STATE_NAMES[] = {
	 "sendMessage_IDLE"
	,"sendMessage_IN_SESSION"
	,"sendMessage_AWAITING_ACK"
};

#endif
</pre>
</body>
</html>
