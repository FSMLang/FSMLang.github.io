.. role:: fsmlang(code)
	:language: fsmlang

===============
Event Sequences
===============

A finite state machine should be designed not only with a clear identification of the events the machine must handle,
but also with an understanding of the order in which these events will occur.  To facilitate this, FSMLang provides for
the declaration of these event sequences at the end of the machine.

Recalling the :ref:`the-simple-communicator`, we can list at least two event sequences which the machine must handle:

.. code-block:: fsmlang

	sequence seq1 SEND_MESSAGE, ACK;
	sequence seq2 SEND_MESSAGE, SEND_MESSAGE, ACK, SEND_MESSAGE, ACK;

The first sequence represents requesting to send a message and receiving the acknowledgement before another message is
sent, whereas the second sequence represents requesting to send two messages before the first acknowledgement is
received.

Executing `fsm -tp --add-plantuml-title simpleCommunicator.fsm` yields the following PlantUML diagrams, in addition
to the basic machine diagram:

.. uml::

	/'
		seq1.plantuml
	
		This file generated by FSMLang
	
	
	'/
	
	@startuml
	title seq1
	state IDLE
	state AWAITING_ACK
	[*] --> IDLE
	IDLE --> AWAITING_ACK: **Event 1:** SEND_MESSAGE\n **Action:** sendMessage
	AWAITING_ACK --> IDLE: **Event 2:** ACK\n **Action:** checkQueue
	
	@enduml
	
.. uml::

	/'
		seq2.plantuml
	
		This file generated by FSMLang
	
	
	'/
	
	@startuml
	title seq2
	state IDLE
	state AWAITING_ACK
	[*] --> IDLE
	IDLE --> AWAITING_ACK: **Event 1:** SEND_MESSAGE\n **Action:** sendMessage
	AWAITING_ACK --> AWAITING_ACK: **Event 2:** SEND_MESSAGE\n **Action:** queueMessage
	AWAITING_ACK --> IDLE: **Event 3:** ACK\n **Action:** checkQueue
	IDLE --> AWAITING_ACK: **Event 4:** SEND_MESSAGE\n **Action:** sendMessage
	AWAITING_ACK --> IDLE: **Event 5:** ACK\n **Action:** checkQueue
	
	@enduml

.. toctree::
	:maxdepth: 2

	Source/index
