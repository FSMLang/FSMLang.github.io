..
   simpleCommunicator.rst

   This file automatically generated by FSMLang

===================
simpleCommunicator
===================

This machine manages communications using a "stop and wait" protocol.
Only one 
message is allowed to be outstanding.




.. list-table:: Machine Statistics
   :align: left

   * - Number of events:
     - 3
   * - Events not handled:
     - 0
   * - Events handled in one state:
     - 1
   * - At least one event handled the same in all states?
     - yes
   * - Number of states:
     - 2
   * - Number of states with entry functions:
     - 0
   * - Number of states with exit functions:
     - 0
   * - States handling no events:
     - 0
   * - States handling exactly one event:
     - 0
   * - States with no way in:
     - 0
   * - States with no way out:
     - 0



.. list-table:: State Chart
   :align: left
   :header-rows: 1
   :stub-columns: 1
   :class: scrollable

   * -
     - :ref:`SEND_MESSAGE <simpleCommunicator.SEND_MESSAGE>`
     - :ref:`NEVER_SEEN <simpleCommunicator.NEVER_SEEN>`
     - :ref:`ACK <simpleCommunicator.ACK>`
   * - :ref:`IDLE <simpleCommunicator.IDLE>`
     - | :ref:`sendMessage <simpleCommunicator.sendMessage>`
       | transition: :ref:`AWAITING_ACK <simpleCommunicator.AWAITING_ACK>`
     - :ref:`neverExecuted <simpleCommunicator.neverExecuted>`
     - 
   * - :ref:`AWAITING_ACK <simpleCommunicator.AWAITING_ACK>`
     - :ref:`queueMessage <simpleCommunicator.queueMessage>`
     - :ref:`neverExecuted <simpleCommunicator.neverExecuted>`
     - | :ref:`checkQueue <simpleCommunicator.checkQueue>`
       | transition: :ref:`IDLE <simpleCommunicator.IDLE>`


Events
-------


.. _simpleCommunicator.SEND_MESSAGE:

SEND_MESSAGE
~~~~~~~~~~~~~

These states handle this event:

* :ref:`IDLE <simpleCommunicator.IDLE>`
* :ref:`AWAITING_ACK <simpleCommunicator.AWAITING_ACK>`


This yields a state density of 100%.



These actions are taken in response to this event:

* :ref:`sendMessage <simpleCommunicator.sendMessage>`
* :ref:`queueMessage <simpleCommunicator.queueMessage>`


.. _simpleCommunicator.NEVER_SEEN:

NEVER_SEEN
~~~~~~~~~~~

This event is handled identically in all states.



These states handle this event:

* :ref:`IDLE <simpleCommunicator.IDLE>`
* :ref:`AWAITING_ACK <simpleCommunicator.AWAITING_ACK>`


This yields a state density of 100%.



These actions are taken in response to this event:

* :ref:`neverExecuted <simpleCommunicator.neverExecuted>`


.. _simpleCommunicator.ACK:

ACK
~~~~

This event is handled identically in 1 states.



These states handle this event:

* :ref:`AWAITING_ACK <simpleCommunicator.AWAITING_ACK>`


This yields a state density of 50%.



These actions are taken in response to this event:

* :ref:`checkQueue <simpleCommunicator.checkQueue>`


States
-------


.. _simpleCommunicator.IDLE:

IDLE
~~~~~

These events are handled in this state:

* :ref:`NEVER_SEEN <simpleCommunicator.NEVER_SEEN>`
* :ref:`SEND_MESSAGE <simpleCommunicator.SEND_MESSAGE>`


This yields an event density of 66%.



These actions are taken in this state:

* :ref:`neverExecuted <simpleCommunicator.neverExecuted>`
* :ref:`sendMessage <simpleCommunicator.sendMessage>`


These states transition into this state:

* :ref:`AWAITING_ACK <simpleCommunicator.AWAITING_ACK>`


This state transitions into these states:

* :ref:`AWAITING_ACK <simpleCommunicator.AWAITING_ACK>`


.. _simpleCommunicator.AWAITING_ACK:

AWAITING_ACK
~~~~~~~~~~~~~

These events are handled in this state:

* :ref:`NEVER_SEEN <simpleCommunicator.NEVER_SEEN>`
* :ref:`SEND_MESSAGE <simpleCommunicator.SEND_MESSAGE>`
* :ref:`ACK <simpleCommunicator.ACK>`


This yields an event density of 100%.



These actions are taken in this state:

* :ref:`neverExecuted <simpleCommunicator.neverExecuted>`
* :ref:`queueMessage <simpleCommunicator.queueMessage>`
* :ref:`checkQueue <simpleCommunicator.checkQueue>`


These states transition into this state:

* :ref:`IDLE <simpleCommunicator.IDLE>`


This state transitions into these states:

* :ref:`IDLE <simpleCommunicator.IDLE>`


Actions
--------


.. _simpleCommunicator.neverExecuted:

neverExecuted
~~~~~~~~~~~~~~

.. _simpleCommunicator.sendMessage:

sendMessage
~~~~~~~~~~~~

sendMessage sends a message from the queue. The
message is expected to be there, 
since
checkQueue will have been previously called.




This action returns:

* noEvent



.. _simpleCommunicator.queueMessage:

queueMessage
~~~~~~~~~~~~~

queueMessage adds a message to the queue 



This action returns:

* noEvent



.. _simpleCommunicator.checkQueue:

checkQueue
~~~~~~~~~~~

checkQueue only checks; it does not dequeue; that
is done by sendMessage.

Return 
SEND_MESSAGE when the queue is not empty.




This action returns:

* :ref:`SEND_MESSAGE <simpleCommunicator.SEND_MESSAGE>`
* noEvent



Event Sequences
---------------------

.. list-table::
   :align: left
   :header-rows: 1
   :stub-columns: 1

   * - Name
     - Comment
     - Initial State
     - Sequence
     - Final State
   * - seq1
     - 
     - IDLE
     - * SEND_MESSAGE: IDLE ->AWAITING_ACK (sendMessage)
       * ACK: AWAITING_ACK ->IDLE (checkQueue)

     - Traced: IDLE
   * - seq2
     - 
     - IDLE
     - * SEND_MESSAGE: IDLE ->AWAITING_ACK (sendMessage)
       * SEND_MESSAGE: AWAITING_ACK ->AWAITING_ACK (queueMessage)
       * ACK: AWAITING_ACK ->IDLE (checkQueue)
       * SEND_MESSAGE: IDLE ->AWAITING_ACK (sendMessage)
       * ACK: AWAITING_ACK ->IDLE (checkQueue)

     - Traced: IDLE
